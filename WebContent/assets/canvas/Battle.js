
// -- user code here --

/* --- start generated code --- */

// Generated by  1.5.0 (Phaser v2.6.2)


/**
 * Battle.
 */
function Battle() {
	
	Phaser.State.call(this);
	
}

/** @type Phaser.State */
var Battle_proto = Object.create(Phaser.State.prototype);
Battle.prototype = Battle_proto;
Battle.prototype.constructor = Battle;

Battle.prototype.init = function () {
	
};

Battle.prototype.preload = function () {
	
	//--Generated Spine load (from user canvas code)
	this.load.spine( 'avatar', 'assets/animations/spineboy.json' );
	
};

Battle.prototype.create = function () {
	var _bg = this.add.sprite(0.0, 0.0, 'bg');
	_bg.name = 'bg';
	
	var _stage = this.add.sprite(69.0, 244.0, 'all-images', 'stage');
	_stage.name = 'stage';
	_stage.alpha = 0.8;
	
	var _linesGroup = this.add.group();
	_linesGroup.name = 'linesGroup';
	_linesGroup.position.setTo(79.0, 254.0);
	
	var _dotsGroup = this.add.group();
	_dotsGroup.name = 'dotsGroup';
	_dotsGroup.position.setTo(79.0, 254.0);
	
	var _particlesGroup = this.add.group();
	_particlesGroup.name = 'particlesGroup';
	_particlesGroup.position.setTo(79.0, 254.0);
	
	var _btnBack = this.add.group();
	_btnBack.name = 'btnBack';
	_btnBack.fixedToCamera = true;
	
	var _btnBackBg = this.add.button(360.0, 8.0, 'all-images', this.toMenuState, this, null, 'line', null, null, _btnBack);
	_btnBackBg.name = 'btnBackBg';
	_btnBackBg.scale.setTo(1.7, 4.0);
	_btnBackBg.alpha = 0.9;
	
	var _btnBackText = this.add.text(376.0, 16.0, 'BACK', {"font":"bold 20px Arial","fill":"#9e627c","align":"center"}, _btnBack);
	_btnBackText.name = 'btnBackText';
	
	var _squareIndicator = this.add.sprite(210.0, 385.0, 'all-images', 'dot');
	_squareIndicator.name = 'squareIndicator';
	_squareIndicator.scale.setTo(40.0, 40.0);
	_squareIndicator.alpha = 0.2;
	_squareIndicator.anchor.setTo(0.5, 0.5);
	
	
	
	// public fields
	
	this.fStage = _stage;
	this.fLinesGroup = _linesGroup;
	this.fDotsGroup = _dotsGroup;
	this.fParticlesGroup = _particlesGroup;
	this.fSquareIndicator = _squareIndicator;
	
	//--Generated code from canvas user code
	this.initStage();
	
};

/* --- end generated code --- */
// -- user code here --

// CONSTANTS
Battle.prototype.GRID_WIDTH             = 6;    // columns
Battle.prototype.GRID_HEIGHT            = 6;    // rows
Battle.prototype.DOT_SIZE               = 32;   // px;
Battle.prototype.DOT_SPACE              = 20;   // px
Battle.prototype.FALL_1_FLOOR_DURATION  = 150;  // ms
Battle.prototype.DOT_ANIM_DURATION      = 150;  // ms
Battle.prototype.HIGHLIGHT_DURATION     = 400;  // ms
Battle.prototype.LIVE_LINE_LENGTH       = 52;   // px
Battle.prototype.EXPLODE_MAX_PARTICLES  = 5;
Battle.prototype.EXPLODE_LIFE_SPAN      = 1600;
Battle.prototype.EMPTY                  = 0;
Battle.prototype.COLORS                 = [0xFFE368, 0xDE369D, 0x59C9A5, 0x1A8FE3]; // Yellow, Red, Green, Blue
Battle.prototype.NUMBER_OF_COLORS       = Battle.prototype.COLORS.length;
Battle.prototype.PHASES                 = ["ACTION", "Wait..."];
Battle.prototype.PHASE_ACTION           = 0;
Battle.prototype.PHASE_WAIT             = 1;
//-----------------------------------------------------------------------------------------------------------
// CONFIG
Battle.prototype.DEBUG_ENABLE           = false;
Battle.prototype.PARTICLE_ENABLE        = true;
Battle.prototype.USE_EXPORTED_PARTICLE  = false; // TODO: didn't work yet
Battle.prototype.SPINE_ENABLE           = true;
Battle.prototype.LIVE_LINE_ENABLE       = true;
Battle.prototype.USE_TWEEN_POOL         = false; // doesn't work yet, because giving tween back to pool needs callback
Battle.prototype.FX_CONNECT_ENABLE      = true;
//-----------------------------------------------------------------------------------------------------------
// PROPERTIES
Battle.prototype.poolOfDots             = null;
Battle.prototype.mapOfLines             = [];
Battle.prototype.listOfVisibleLines     = [];
Battle.prototype.mapOfExplodeFxs        = [];
Battle.prototype.tableOfTypes           = [];
Battle.prototype.tableOfDots            = [];
Battle.prototype.phase                  = Battle.prototype.PHASE_WAIT;
Battle.prototype.listOfConnectedDots    = [];
Battle.prototype.connectingType         = Battle.prototype.EMPTY;
Battle.prototype.isSquareFormed         = false;
Battle.prototype.avatar                 = null;
Battle.prototype.isGrabbing             = false;
Battle.prototype.liveLine               = null;
Battle.prototype.mapOfSfxs              = [];
Battle.prototype.cachedStageX           = 0;
Battle.prototype.cachedStageY           = 0;
Battle.prototype.cachedGroupX           = 0;
Battle.prototype.cachedGroupY           = 0;
Battle.prototype.poolOfTweens           = null;
Battle.prototype.mapOfConnectFxs        = [];
//-----------------------------------------------------------------------------------------------------------
/**
 * Initialize everything
 */
Battle.prototype.initStage = function () {
    // Cache unchanged numbers
    this.cachedStageX = this.fStage.x;
    this.cachedStageY = this.fStage.y;
    this.cachedGroupX = this.fDotsGroup.x;
    this.cachedGroupY = this.fDotsGroup.y;

    // Init many things
    this.initPoolOfDots();
    this.initLineGrid();
    this.initParticles();
    this.initAnimations();
    this.initAudio();
    this.initTweens();
    this.initConnectFxs();
    this.initSquareIndicator();

    // Init tableOfDots state as empty
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        this.tableOfTypes[i] = [];
        this.tableOfDots[i] = [];
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            this.tableOfTypes[i][k] = this.EMPTY;
        }
    }

    // Move dots from poolOfDots to tableOfDots
    this.spawnDots();

    // Setup interaction
    this.input.onDown.add( this.onGrab, this );
    this.input.addMoveCallback( this.onMovePointer, this );
    this.input.onUp.add( this.onRelease, this );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Spawn new dots into tableOfDots
 * @param excludeType : don't pick this color (bonus when square is formed)
 */
Battle.prototype.spawnDots = function (excludeType) {
    var duration = 0;
    var longestDuration = 0;

    // Setup colors to pick
    var availableColors = [];
    for (var i = 1; i <= this.NUMBER_OF_COLORS; ++i) {
        if (i != excludeType) {
            availableColors.push( i );
        }
    }
//    console.log( "exclude " + excludeType + " => " + availableColors );

    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        // move old dots down
        var kOccupied;
        var kEmpty = this.GRID_HEIGHT - 1;
        do {
            while (kEmpty >= 0 && !this.isEmpty( this.tableOfTypes[i][kEmpty] )) { --kEmpty; }          // find empty slot (may not found)
            kOccupied = kEmpty - 1;
            while (kOccupied >= 0 && this.isEmpty( this.tableOfTypes[i][kOccupied] )) { --kOccupied; }  // find occupied slot above empty slot (may not found)
            if (kOccupied >= 0 && kEmpty >= 0) { // fact: kOccupied != kEmpty
                // move dot to empty slot
                /** @type Phaser.Sprite */ var dot = this.tableOfDots[i][kOccupied];
                this.tableOfDots[i][kOccupied] = null;
                this.tableOfDots[i][kEmpty]    = dot;

                // update type matrix
                this.tableOfTypes[i][kEmpty]    = this.tableOfTypes[i][kOccupied];
                this.tableOfTypes[i][kOccupied] = this.EMPTY;

                // tween
                duration = this.FALL_1_FLOOR_DURATION * (kEmpty - kOccupied);
                if (this.USE_TWEEN_POOL) {
                    this.getTweenFor( dot )
                        .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
                } else {
                    this.add.tween(dot)
                        .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
                }
                longestDuration = Math.max( duration, longestDuration );
            }
        } while (kOccupied >= 0 && kEmpty >= 0);

        // skip if column is full
        if (kEmpty < 0) { continue; }

        // spawn new dots
        var countNewDots = kEmpty + 1;
        var duration     = this.FALL_1_FLOOR_DURATION * countNewDots;
        while (kEmpty >= 0) {
            // Get new dot
            // Don't need to have /** @type */ before 'var', because 'getDotFromPool' specified return type
            /** @type Phaser.Sprite */ var dot = this.getDotFromPool();
            dot.position.set( this.colToX( i ), this.rowToY( kEmpty - countNewDots ) );

            // save position & type
            var dotType                  = Phaser.ArrayUtils.getRandomItem( availableColors );
            this.tableOfDots[i][kEmpty]  = dot;
            this.tableOfTypes[i][kEmpty] = dotType;
            dot.tint                     = this.COLORS[ dotType - 1 ];

            // tween
            if (this.USE_TWEEN_POOL) {
                this.getTweenFor( dot )
                    .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
            } else {
                this.add.tween(dot)
                    .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
            }
            --kEmpty;
        }
        longestDuration = Math.max( duration, longestDuration );
    }

    this.time.events.add( longestDuration, this.switchPhase, this, this.PHASE_ACTION );

//    console.log("after spawning");
//    this.poolOfDots.debug();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Create all dots needed for the game and put them in a poolOfDots for re-using later
 */
Battle.prototype.initPoolOfDots = function () {
    var capacity    = this.GRID_WIDTH * this.GRID_HEIGHT * 2;
    this.poolOfDots = new RecyclePool( capacity );
    var dotsGroup   = this.fDotsGroup;
    for (var i = 0; i < capacity; ++i) {
        /** @type Phaser.Sprite */ var dot = this.add.sprite( 0, 0, 'all-images', 'dot', dotsGroup );
        dot.anchor.set( 0.5 );
        dot.data = { id : i }; // for debug only
        dot.name = 'dot_' + i; // to view in Phaser.Plugin.Debug.SceneTree
        this.returnDotToPool( dot );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * @returns {Phaser.Sprite} Dot (in poolOfDots) ready to use
 */
Battle.prototype.getDotFromPool = function () {
    /** @type Phaser.Sprite */ var dot = this.poolOfDots.takeOut();
    dot.scale.set( 1 );
    dot.visible    = true;
    return dot;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param dot : This dot is destroyed -> put back into poolOfDots
 */
Battle.prototype.returnDotToPool = function (dot) {
    dot.visible     = false;
    this.poolOfDots.giveBack( dot );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Initialize connections between dots
 */
Battle.prototype.initLineGrid = function () {
    var linesGroup = this.fLinesGroup;
    for (var i = 0; i < this.GRID_WIDTH - 1; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            /** @type Phaser.Sprite */ var line = this.add.sprite( 0, 0, 'all-images', 'line', linesGroup );
            line.anchor.set( 0, 0.5 );
            line.position.set( this.colToX(i), this.rowToY(k) );
            line.visible    = false;

            var id1 = this.colRowToIndex(i, k);
            var id2 = this.colRowToIndex(i + 1, k);
            this.mapOfLines[ this.getLineIndexBetween(id1, id2) ] =
            this.mapOfLines[ this.getLineIndexBetween(id2, id1) ] = line;
            line.name = 'line_' + this.getLineIndexBetween(id1, id2); // to view in Phaser.Plugin.Debug.SceneTree
        }
    }

    var rotation = Math.PI / 2;
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT - 1; ++k) {
            /** @type Phaser.Sprite */ var line = this.add.sprite( 0, 0, 'all-images', 'line', linesGroup );
            line.anchor.set( 0, 0.5 );
            line.position.set( this.colToX(i), this.rowToY(k) );
            line.rotation   = rotation;
            line.visible    = false;

            var id1 = this.colRowToIndex(i, k);
            var id2 = this.colRowToIndex(i, k + 1);
            this.mapOfLines[ this.getLineIndexBetween(id1, id2) ] =
            this.mapOfLines[ this.getLineIndexBetween(id2, id1) ] = line;
            line.name = 'line_' + this.getLineIndexBetween(id1, id2); // to view in Phaser.Plugin.Debug.SceneTree
        }
    }

    if (!this.LIVE_LINE_ENABLE) { return; }
    /** @type Phaser.Sprite */ var line = this.add.sprite( 0, 0, 'all-images', 'line', linesGroup );
    line.anchor.set( 0, 0.5 );
    line.visible    = false;
    this.liveLine   = line;
    line.name = 'line_LIVE'; // to view in Phaser.Plugin.Debug.SceneTree
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param i1 : Index of dot #1
 * @param i2 : Index of dot #2
 * @returns Key to get connection between these dots
 */
Battle.prototype.getLineIndexBetween = function (i1, i2) {
    return (i1 + '_' + i2);
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param i1 : Index of dot #1
 * @param i2 : Index of dot #2
 * @returns Connection between these dots
 */
Battle.prototype.getLineBetween = function (i1, i2) {
    return this.mapOfLines[ this.getLineIndexBetween( i1, i2 ) ];
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Hide all dot connections
 */
Battle.prototype.hideGridLines = function () {
    for (var i = 0; i < this.listOfVisibleLines.length; ++i) {
        this.listOfVisibleLines[i].visible      = false;
    }
    this.listOfVisibleLines = [];

    if (!this.LIVE_LINE_ENABLE) { return; }
    this.liveLine.visible       = false;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param t : Dot type in this slot
 * @returns Check if this slot is empty or not
 */
Battle.prototype.isEmpty = function (t) {
    return (t == this.EMPTY);
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [INPUT] On mouse down
 */
Battle.prototype.onGrab = function () {
    /** @type Phaser.Pointer */ var pointer = this.input.activePointer;
    var col = Math.floor( (pointer.position.x - this.cachedStageX) / (this.DOT_SIZE + this.DOT_SPACE) );
    var row = Math.floor( (pointer.position.y - this.cachedStageY) / (this.DOT_SIZE + this.DOT_SPACE) );
    this.isGrabbing = this.isOnBoard( col, row );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [INPUT] On mouse move
 * @param pointer
 */
Battle.prototype.onMovePointer = function (pointer) {
    if (this.phase != this.PHASE_ACTION) { return; }    // not ACTION time
    if (!pointer.isDown) { return; }                    // no touching
    if (!this.isGrabbing) { return; }                   // first touch is outside of stage

    var col = Math.floor( (pointer.position.x - this.cachedStageX) / (this.DOT_SIZE + this.DOT_SPACE) );
    var row = Math.floor( (pointer.position.y - this.cachedStageY) / (this.DOT_SIZE + this.DOT_SPACE) );
    if (this.isOnBoard( col, row )) {
        this.onTouch( col, row );
    }

    if (!this.LIVE_LINE_ENABLE) { return; }
    if (this.listOfConnectedDots.length == 0) {
        return;
    }
    /** @type Phaser.Point */ var dotPos = this.liveLine.position;
    /** @type Phaser.Point */ var curPos = new Phaser.Point( pointer.position.x - this.cachedGroupX, pointer.position.y - this.cachedGroupY );
    this.liveLine.scale.set( (dotPos.distance( curPos )) / this.LIVE_LINE_LENGTH, 1 );
    this.liveLine.rotation = dotPos.angle( curPos );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [INPUT] On mouse up
 */
Battle.prototype.onRelease = function () {
    this.isGrabbing = false;
    if (!this.isConnecting()) { return; }

    if (this.listOfConnectedDots.length > 1) {
        this.matchDots();
        this.spawnDots( this.connectingType );
    } else {
        this.cancelConnecting();
    }

    this.connectingType = this.EMPTY;
    this.hideSquareIndicator();
    this.hideGridLines();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [DEBUG]
 */
Battle.prototype.render = function () {
    if (this.DEBUG_ENABLE) {
        // PHASE
        this.debug.text( this.PHASES[ this.phase ], 10, 20, 'red' );

        // DOTS - TYPE (if debug text has same color with dot (hard to read) => correct)
        var offsetX = this.cachedStageX + this.DOT_SIZE / 2 - 12;
        var offsetY = this.cachedStageY + this.DOT_SIZE / 2;
        for (var i = 0; i < this.GRID_WIDTH; ++i) {
            for (var k = 0; k < this.GRID_HEIGHT; ++k) {
                if (!this.isEmpty( this.tableOfTypes[i][k] )) {
                    this.debug.text(
                        this.tableOfTypes[i][k],
                        offsetX + this.tableOfDots[i][k].x,
                        offsetY + this.tableOfDots[i][k].y,
                        Phaser.Color.getWebRGB( this.COLORS[ this.tableOfTypes[i][k] - 1 ] )
                    );
                }
            }
        }

        // DOTS - CONNECTING
        if (this.phase != this.PHASE_ACTION || !this.isConnecting()) { return; }
        for (var i = 0; i < this.listOfConnectedDots.length; ++i) {
            var c = this.indexToCol( this.listOfConnectedDots[i] );
            var r = this.indexToRow( this.listOfConnectedDots[i] );
            this.debug.spriteBounds( this.tableOfDots[c][r] );
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * Main game logic: Handle when mouse touches dot
 * @param col
 * @param row
 */
Battle.prototype.onTouch = function (col, row) {
    var type = this.tableOfTypes[col][row];
    if (this.isEmpty( type )) { return; }

    // Case 1: Set as 1st dot---------------------------------------------
    var index = this.colRowToIndex( col, row );
    if (!this.isConnecting()) {
        this.connectingType      = type;
        this.listOfConnectedDots = [ index ];
        this.isSquareFormed      = false;
        this.onConnectNewDot( index );
        console.log( "Begin connecting " + type + ": " + this.listOfConnectedDots );
        return;
    }

    // early reject from case 2, 3, 4
    var dotsCount = this.listOfConnectedDots.length;
    if (type != this.connectingType) { return; }                                // is different color
    if (index == this.listOfConnectedDots[ dotsCount - 1 ]) { return; }                    // is last connected dot
    if (!this.isAdjacent(index, this.listOfConnectedDots[ dotsCount - 1 ])) { return; }    // is not adjacent

    // Case 2: Cancel newest dot---------------------------------------------
    var duplicatedPos = this.listOfConnectedDots.indexOf( index );
    var lastDotIndex  = this.listOfConnectedDots[ dotsCount - 1 ];
    if (duplicatedPos > -1 && duplicatedPos == dotsCount - 2) {
        this.onDisconnectDot( lastDotIndex, this.listOfConnectedDots[ dotsCount - 2 ] );
        this.listOfConnectedDots.pop();
        this.isSquareFormed = false;
        this.hideSquareIndicator();
        console.log( "\tReject " + type + ": " + this.listOfConnectedDots );
        return;
    }

    // If square was formed already -> early reject from case 3, 4
    if (this.isSquareFormed) { return; }

    // Case 3: Add new dot---------------------------------------------
    if (duplicatedPos == -1) {
        this.listOfConnectedDots.push( index );
        this.onConnectNewDot( index, lastDotIndex );
        console.log( "\tAdd " + type + ": " + this.listOfConnectedDots );
        return;
    }

    // If there's not enough dots to form a square -> early reject from case 4
    if (duplicatedPos > dotsCount - 4) { return; }

    // Case 4: Square---------------------------------------------
    var turnsCount = 0;
    var direction = this.isAdjacentAndOnSameRow( this.listOfConnectedDots[ duplicatedPos ], this.listOfConnectedDots[ duplicatedPos + 1 ] );
    do {
        ++duplicatedPos;
        var newDirection = this.isAdjacentAndOnSameRow( this.listOfConnectedDots[ duplicatedPos ], this.listOfConnectedDots[ duplicatedPos + 1 ] );
        if (direction != newDirection) {
            direction = newDirection;
            ++turnsCount;
        }
    } while (duplicatedPos < dotsCount - 1);
    if (turnsCount < 4) {
        this.listOfConnectedDots.push( index );
        this.onConnectNewDot( index, lastDotIndex );
        console.log( "\t[SQUARE] Re-Add " + type + ": " + this.listOfConnectedDots );
        this.isSquareFormed = true;
        this.showSquareIndicator( col, row, this.connectingType );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * On mouse up and there're dots to match
 */
Battle.prototype.matchDots = function () {
    if (!this.isConnecting()) { return; }

    this.switchPhase( this.PHASE_WAIT );
    if (this.isSquareFormed) {
        console.log( "Clear ALL dots type " + this.connectingType );
        this.clear( this.getDotsWhichIs( this.connectingType ) );
        this.camera.shake( 0.01, this.DOT_ANIM_DURATION ); // UI is fixed with camera
        this.sfx( 'clear' );
    } else {
        console.log( "Clear matched dots type " + this.connectingType );
        this.clear( this.listOfConnectedDots );
        this.sfx( 'match' );
    }
    this.animateAvatarOnMatch( this.isSquareFormed );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * On mouse up and there're not enough dots to match
 */
Battle.prototype.cancelConnecting = function () {
    for (var i = 0; i < this.listOfConnectedDots.length; ++i) {
        this.onDisconnectDot( this.listOfConnectedDots[i] );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * @param indices : Index of dots to be destroyed
 */
Battle.prototype.clear = function (indices) {
    var dots = [];
    var color = this.connectingType;
    for (var i = 0; i < indices.length; ++i) {
        var id  = indices[i];
        var c   = this.indexToCol( id );
        var r   = this.indexToRow( id );

        this.tableOfTypes[c][r] = this.EMPTY;
        dots.push( this.tableOfDots[c][r] );

        if (this.USE_TWEEN_POOL) {
            this.getTweenFor( this.tableOfDots[c][r].scale )
                .to( {x: 0, y:0}, this.DOT_ANIM_DURATION, Phaser.Easing.Quadratic.Out, true );
        } else {
            this.add.tween( this.tableOfDots[c][r].scale )
                .to( {x: 0, y:0}, this.DOT_ANIM_DURATION, Phaser.Easing.Quadratic.Out, true );
        }

        this.showParticleAt( id, color );
    }
    this.time.events.add( this.DOT_ANIM_DURATION, this.postClear, this, dots );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param dots : Wait for dots to finish 'EXPLODE' animation, then return them to poolOfDots to re-use later
 */
Battle.prototype.postClear = function (dots) {
    for (var i = 0; i < dots.length; ++i) {
        this.returnDotToPool( dots[i] );
    }

//    console.log("post clearing");
//    this.poolOfDots.debug();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @returns
 * @param type : Filter dots by color (type)
 */
Battle.prototype.getDotsWhichIs = function (type) {
    var dots = [];
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            if (this.tableOfTypes[i][k] == type) {
                dots.push( this.colRowToIndex(i, k) );
            }
        }
    }
    return dots;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] VFX when connect new dot
 * @param newDotIndex : New connected dot
 * @param lastDotIndex : Last dot before connecting
 */
Battle.prototype.onConnectNewDot = function (newDotIndex, lastDotIndex) {
    var c = this.indexToCol( newDotIndex );
    var r = this.indexToRow( newDotIndex );
    /** @type Phaser.Sprite */ var dot = this.tableOfDots[c][r];

    // highlight dot
    if (this.FX_CONNECT_ENABLE) {
        this.showConnectFxAt( c, r );
    } else {
        if (this.USE_TWEEN_POOL) {
            this.stopTweensOf( dot.scale );
            this.getTweenFor( dot.scale )
                .to( { x : 1.2, y : 1.2 }, this.DOT_ANIM_DURATION, Phaser.Easing.Bounce.Out, true );
        } else {
            this.tweens.remove( dot.scale );
            this.add.tween( dot.scale )
                .to( { x : 1.2, y : 1.2 }, this.DOT_ANIM_DURATION, Phaser.Easing.Bounce.Out, true );
        }
    }
    this.sfx( 'connect' );

    // show connection
    if (lastDotIndex != undefined) {
        /** @type Phaser.Sprite */ var line = this.getLineBetween( newDotIndex, lastDotIndex );
        if (this.listOfVisibleLines.indexOf(line) > -1) {
            return;
        }
        this.listOfVisibleLines.push( line );
        line.tint       = this.COLORS[ this.connectingType - 1 ];
        line.visible    = true;
    }

    if (!this.LIVE_LINE_ENABLE) { return; }
    this.liveLine.position      = dot.position;
    this.liveLine.tint          = this.COLORS[ this.connectingType - 1 ];
    this.liveLine.visible       = true;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] VFX when disconnect a dot
 * @param dotIndex : Disconnected dot
 * @param lastDotIndex : New last dot
 */
Battle.prototype.onDisconnectDot = function (dotIndex, lastDotIndex) {
    var c = this.indexToCol( dotIndex );
    var r = this.indexToRow( dotIndex );
    /** @type Phaser.Sprite */ var dot = this.tableOfDots[c][r];

    // un-highlight dot
    if (!this.FX_CONNECT_ENABLE) {
        if (this.USE_TWEEN_POOL) {
            this.stopTweensOf( dot.scale );
            this.getTweenFor( dot.scale )
                .to( { x : 1, y : 1 }, this.DOT_ANIM_DURATION, Phaser.Easing.Cubic.Out, true );
        } else {
            this.tweens.remove( dot.scale );
            this.add.tween( dot.scale )
                .to( { x : 1, y : 1 }, this.DOT_ANIM_DURATION, Phaser.Easing.Cubic.Out, true );
        }
    }
    this.sfx( 'disconnect' );

    // hide connection
    if (lastDotIndex != undefined) {
        /** @type Phaser.Sprite */ var line = this.getLineBetween( dotIndex, lastDotIndex );
        var lineIndex = this.listOfVisibleLines.lastIndexOf( line );
        if (lineIndex == -1) {
            return;
        }
        this.listOfVisibleLines.splice( lineIndex, 1 );
        line.visible    = false;

        if (!this.LIVE_LINE_ENABLE) { return; }
        var c = this.indexToCol( lastDotIndex );
        var r = this.indexToRow( lastDotIndex );
        /** @type Phaser.Sprite */ var dot = this.tableOfDots[c][r];
        this.liveLine.position = dot.position;
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * 
 */
Battle.prototype.initSquareIndicator = function () {
    this.hideSquareIndicator();
    this.fSquareIndicator.scale.set( 0 );
    /** @type Phaser.Tween */var tween = this.add.tween( this.fSquareIndicator.scale )
        .to( { x : 40, y : 40 }, 200 ).loop().start();
    tween.pause();
    tween.onLoop.add( this._onSquareIndicatorLoop, this );
    this.fSquareIndicator.data = { tween : tween };
    
    // TODO: Can't restart tween now -> Trick: Repeat tween infinitely, but pause after each loop, then resume later
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] VFX when a square is formed
 * @param col
 * @param row
 * @param type : Square color
 */
Battle.prototype.showSquareIndicator = function (col, row, type) {
    /** @type Phaser.Point */var p = this.tableOfDots[col][row].worldPosition;
    this.fSquareIndicator.position.setTo( p.x, p.y );
    this.fSquareIndicator.tint          = this.COLORS[ type - 1 ];
    this.fSquareIndicator.visible       = true;
    if (this.fSquareIndicator.data.tween.isPaused) {
        this.fSquareIndicator.data.tween.resume();
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] Hide square VFX
 */
Battle.prototype.hideSquareIndicator = function () {
    this.fSquareIndicator.visible       = false;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * @param target : tween target (passed by Phaser.Tween.onLoop)
 * @param tween : tween (passed by Phaser.Tween.onLoop)
 */
Battle.prototype._onSquareIndicatorLoop = function (target, tween) {
    tween.pause();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [PARTICLES] Create particles (without starting)
 */
Battle.prototype.initParticles = function () {
    if (!this.PARTICLE_ENABLE) { return; }
    var particlesGroup = this.fParticlesGroup;

    if (this.USE_EXPORTED_PARTICLE) {
        var fxExplode = this.cache.getJSON( 'fx-explode' );
        for (var i = 0; i < this.GRID_WIDTH; ++i) {
            for (var k = 0; k < this.GRID_HEIGHT; ++k) {
                /** @type Phaser.Group */
                var emitter = this.game.epsy.loadSystem( fxExplode, 200, 200 );
                particlesGroup.add( emitter );
                emitter.position.set( this.colToX(i), this.rowToY(k) );
                this.mapOfExplodeFxs[ this.colRowToIndex(i, k) ] = emitter;
            }
        }
    } else {
        for (var i = 0; i < this.GRID_WIDTH; ++i) {
            for (var k = 0; k < this.GRID_HEIGHT; ++k) {
                /** @type Phaser.Emitter */ var emitter = this.add.emitter( 0, 0, this.EXPLODE_MAX_PARTICLES );
                particlesGroup.add( emitter );
                emitter.makeParticles( 'all-images', 'dot' );
                emitter.position.set( this.colToX(i), this.rowToY(k) );
                emitter.gravity = 0;
                emitter.setAlpha( 1, 0, this.EXPLODE_LIFE_SPAN );
                emitter.setScale( 0.5, 0, 0.5, 0, this.EXPLODE_LIFE_SPAN );
                emitter.setXSpeed( -200, 200 );
                emitter.setYSpeed( -200, 200 );
                this.mapOfExplodeFxs[ this.colRowToIndex(i, k) ] = emitter;

                emitter.name = 'fx_explode_' + this.colRowToIndex(i, k); // to view in Phaser.Plugin.Debug.SceneTree
            }
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [PARTICLES] VFX when a dot explodes
 * @param index : Dot index
 * @param type : Dot color
 */
Battle.prototype.showParticleAt = function (index, type) {
    if (!this.PARTICLE_ENABLE) { return; }

    if (this.USE_EXPORTED_PARTICLE) {
//        this.mapOfExplodeFxs[ index ].emit();
    } else {
        /** @type Phaser.Emitter */ var emitter = this.mapOfExplodeFxs[ index ];
        var color = this.COLORS[ type - 1 ];
        emitter.forEach( function (particle) {
            particle.tint = color;
        } );
        emitter.explode( this.EXPLODE_LIFE_SPAN, this.EXPLODE_MAX_PARTICLES );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [SPINE ANIMATION] Create an instance
 */
Battle.prototype.initAnimations = function () {
    if (!this.SPINE_ENABLE) { return; }

    this.avatar = this.add.spine( 100, this.game.height, 'avatar' );
    this.avatar.scale.set( 0.3 );
    this.avatar.setAnimationByName( 0, 'idle', true );
    this.avatar.name = 'avatar'; // to view in Phaser.Plugin.Debug.SceneTree
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [SPINE ANIMATION] Animate avatar when clearing dots
 * @param clearAll : All dots of certain color are cleared
 */
Battle.prototype.animateAvatarOnMatch = function (clearAll) {
    if (!this.SPINE_ENABLE) { return; }

    if (clearAll) {
        this.avatar.setAnimationByName( 0, 'jump', false );
        this.avatar.setAnimationByName( 1, 'shoot', false );
    } else {
        this.avatar.setAnimationByName( 0, 'shoot', false );
    }
    this.avatar.addAnimationByName( 0, 'idle', true );  // play 'idle' when finish
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [AUDIO] Spawn audio instances
 */
Battle.prototype.initAudio = function () {
    this.loadSfx( 'clear', 0.4 );
    this.loadSfx( 'connect', 0.5 );
    this.loadSfx( 'disconnect' );
    this.loadSfx( 'match' );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [AUDIO] Load & cache SFX
 * @param key : SFX key
 * @param volume (optional) : SFX volume
 */
Battle.prototype.loadSfx = function (key, volume) {
    if (isNaN(volume)) {
        this.mapOfSfxs[ key ] = this.add.sound( 'sfx-' + key );
    } else {
        this.mapOfSfxs[ key ] = this.add.sound( 'sfx-' + key, volume );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [AUDIO] Play SFX
 * @param key : SFX key
 */
Battle.prototype.sfx = function (key) {
    /** @type Phaser.Sound */var s = this.mapOfSfxs[ key ];
    if (s != undefined) {
        s.play();
    } else {
        console.error( 'sfx "' + key + '" not found' );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [TWEEN] Init pool of tweens to recycle later
 */
Battle.prototype.initTweens = function () {
    if (!this.USE_TWEEN_POOL) { return; }

    var capacity      = this.GRID_WIDTH * this.GRID_HEIGHT * 2;
    this.poolOfTweens = new RecyclePool( capacity );
    for (var i = 0; i < capacity; ++i) {
        this.poolOfTweens.giveBack( this.add.tween() );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [TWEEN] Get a tween from recycle pool, reset it
 * @param obj New tween target
 * @returns Tween ready to re-use
 */
Battle.prototype.getTweenFor = function (obj) {
    /** @type Phaser.Tween */var t = this.poolOfTweens.takeOut();
    t.target   = obj;
    t.timeline = [];
    return t;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [TWEEN] Stop all tweens having target = obj
 * @param obj
 * @param complete
 */
Battle.prototype.stopTweensOf = function (obj, complete) {
    var allTweens = this.tweens.getAll();
    for (var i = allTweens.length - 1; i >= 0; --i) {
        if (allTweens[i].target == obj) {
            allTweens[i].stop( complete );
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [CONNECT FX] Create fx, set fixed position and hide all of them
 */
Battle.prototype.initConnectFxs = function () {
    if (!this.FX_CONNECT_ENABLE) { return; }
    
    var particlesGroup = this.fParticlesGroup;
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            var id = this.colRowToIndex(i, k);
            // Create sprite
            /** @type Phaser.Sprite */var fx = this.add.sprite( 0, 0, 'all-images', 'dot', particlesGroup );
            fx.position.set( this.colToX(i), this.rowToY(k) );
            fx.anchor.set( 0.5 );
            fx.visible = false;
            fx.name = 'fx_connect_' + id;
            
            // Create tweens (NOT auto-start)
            /** @type Phaser.Tween */var tweenScale = this.add.tween( fx.scale )
                .to( { x : 3, y : 3 }, this.HIGHLIGHT_DURATION, Phaser.Easing.Cubic.Out, true ).loop();
            tweenScale.pause();
            tweenScale.onLoop.add( this._hideConnectFx, this );
            
            /** @type Phaser.Tween */var tweenAlpha = this.add.tween( fx )
                .to( { alpha : 0 }, this.HIGHLIGHT_DURATION, Phaser.Easing.Cubic.Out, true ).loop();
            tweenAlpha.pause();
            tweenAlpha.onLoop.add( this._hideConnectFx, this );
            // don't use 'addOnce', because I want this callback to be executed everytime tween finishes
            
            this.mapOfConnectFxs[ id ] = {
                sprite : fx,
                tweens : [ tweenScale, tweenAlpha ]
            };
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [CONNECT FX] Show effect when connecting a new dot at a specific position
 * @param c : column
 * @param r : row
 */
Battle.prototype.showConnectFxAt = function (c, r) {
    var fx = this.mapOfConnectFxs[ this.colRowToIndex(c, r) ];
    fx.sprite.tint     = this.COLORS[ this.connectingType - 1 ];
    fx.sprite.visible  = true;
    
    fx.tweens[0].resume();
    fx.tweens[1].resume();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [CONNECT FX] Hide effect when it finished its tween (alpha = 0)
 * @param target : tween target (passed by Phaser.Tween.onLoop)
 * @param tween : tween (passed by Phaser.Tween.onLoop)
 */
Battle.prototype._hideConnectFx = function (target, tween) {
    target.visible = false;
    tween.pause();
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isOnBoard = function (c, r) {
    return (c >= 0 && r >= 0 && c < this.GRID_WIDTH && r < this.GRID_HEIGHT);
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.colRowToIndex = function (col, row) {
    return col * this.GRID_HEIGHT + row;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.indexToCol = function (index) {
    return Math.floor( index / this.GRID_HEIGHT );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.indexToRow = function (index) {
    return Math.floor( index % this.GRID_HEIGHT );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isAdjacentAndOnSameCol = function (i1, i2) { // i1, i2 must be on same column already
    return (Math.abs( i1 - i2 ) == 1);
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isAdjacentAndOnSameRow = function (i1, i2) { // i1, i2 must be on same row already
    return (Math.abs( i1 - i2 ) == this.GRID_WIDTH);
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isAdjacent = function (i1, i2) {
    var c1 = this.indexToCol( i1 );
    var c2 = this.indexToCol( i2 );
    if (c1 == c2) { // same column
        return this.isAdjacentAndOnSameCol( i1, i2 );
    }

    var r1 = this.indexToRow( i1 );
    var r2 = this.indexToRow( i2 );
    if (r1 == r2) { // same row
        return this.isAdjacentAndOnSameRow( i1, i2 );
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.colToX = function (c) {
    return c * (this.DOT_SIZE + this.DOT_SPACE) + 16;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.rowToY = function (r) {
    return r * (this.DOT_SIZE + this.DOT_SPACE) + 16;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isConnecting = function () {
  return !this.isEmpty( this.connectingType );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.switchPhase = function (p) {
    this.phase = p;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.toMenuState = function () {
//    this.state.start( 'Menu', FadeOut, FadeIn ); // TODO: Not smooth enough, think of camera fading
    this.state.start( 'Menu' );
};
