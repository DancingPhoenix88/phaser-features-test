
// -- user code here --

/* --- start generated code --- */

// Generated by  1.5.0 (Phaser v2.6.2)


/**
 * Battle.
 */
function Battle() {

	Phaser.State.call(this);

}

/** @type Phaser.State */
var Battle_proto = Object.create(Phaser.State.prototype);
Battle.prototype = Battle_proto;
Battle.prototype.constructor = Battle;

Battle.prototype.init = function () {

};

Battle.prototype.preload = function () {

	//--Generated custom load (from user canvas code)
	this.load.customPack( 'custom_pack', 'customBattle' );

};

Battle.prototype.create = function () {
	var _bg = this.add.sprite(0.0, 0.0, 'bg');
	_bg.name = 'bg';

	var _stage = this.add.sprite(69.0, 244.0, 'all-images', 'stage');
	_stage.name = 'stage';
	_stage.alpha = 0.8;

	var _linesGroup = this.add.group();
	_linesGroup.name = 'linesGroup';
	_linesGroup.position.setTo(79.0, 254.0);

	var _dotsGroup = this.add.group();
	_dotsGroup.name = 'dotsGroup';
	_dotsGroup.position.setTo(79.0, 254.0);

	var _particlesGroup = this.add.group();
	_particlesGroup.name = 'particlesGroup';
	_particlesGroup.position.setTo(79.0, 254.0);

	var _uiGroup = this.add.group();
	_uiGroup.name = 'UI';
	_uiGroup.fixedToCamera = true;

	var _panelGoal = this.add.group(_uiGroup);
	_panelGoal.name = 'panelGoal';
	_panelGoal.position.setTo(163.0, 14.0);

	var _bgGoal = this.add.sprite(0.0, 0.0, 'all-images', 'line', _panelGoal);
	_bgGoal.name = 'bgGoal';
	_bgGoal.scale.setTo(1.55, 5.0);
	_bgGoal.alpha = 0.4;

	var _imgDotGoal = this.add.sprite(8.0, 10.0, 'all-images', 'dot', _panelGoal);
	_imgDotGoal.name = 'imgDotGoal';

	var _txtGoal = this.add.text(45.0, 12.0, '99', {"font":"bold 24px Arial","fill":"#ffffff","align":"center"}, _panelGoal);
	_txtGoal.name = 'txtGoal';

	var _panelMove = this.add.group(_uiGroup);
	_panelMove.name = 'btnBack';
	_panelMove.position.setTo(23.0, 14.0);

	var _bgMove = this.add.sprite(0.0, 0.0, 'all-images', 'line', _panelMove);
	_bgMove.name = 'bgMove';
	_bgMove.scale.setTo(2.5, 5.0);
	_bgMove.alpha = 0.8;

	var _labelMove = this.add.text(9.0, 15.0, 'MOVES', {"font":"16px Arial","fill":"#666666","align":"center"}, _panelMove);
	_labelMove.name = 'labelMove';

	var _txtMove = this.add.text(79.0, 5.0, '99', {"font":"bold 32px Arial","fill":"#333333","align":"center"}, _panelMove);
	_txtMove.name = 'txtMove';

	var _btnBack = this.add.group(_uiGroup);
	_btnBack.name = 'btnBack';
	_btnBack.position.setTo(-17.0, 9.0);

	var _btnBackBg = this.add.button(360.0, 8.0, 'all-images', this.toMenuState, this, null, 'line', null, null, _btnBack);
	_btnBackBg.name = 'btnBackBg';
	_btnBackBg.scale.setTo(1.7, 4.0);
	_btnBackBg.alpha = 0.9;

	var _btnBackText = this.add.text(376.0, 16.0, 'BACK', {"font":"bold 20px Arial","fill":"#9e627c","align":"center"}, _btnBack);
	_btnBackText.name = 'btnBackText';

	var _modalBg = this.add.button(-35.0, -25.0, 'all-images', null, this, null, 'line', null, null, _uiGroup);
	_modalBg.name = 'modalBg';
	_modalBg.scale.setTo(10.0, 85.0);
	_modalBg.alpha = 0.8;
	_modalBg.renderable = false;
	_modalBg.tint = 0x191919;

	var _modalWin = this.add.group(_uiGroup);
	_modalWin.name = 'modalWin';
	_modalWin.position.setTo(69.00001525878906, 300.0);

	var _bgWin = this.add.sprite(0.0, 0.0, 'all-images', 'line', _modalWin);
	_bgWin.name = 'bgWin';
	_bgWin.scale.setTo(6.0, 20.0);
	_bgWin.alpha = 0.8;

	var _labelWin = this.add.text(79.0, 29.0, 'Mission Complete', {"font":"20px Arial","fill":"#008000","align":"center"}, _modalWin);
	_labelWin.name = 'labelWin';

	var _txtLvWin = this.add.text(124.0, 74.0, '99', {"font":"bold 64px Arial","fill":"#408000","align":"center"}, _modalWin);
	_txtLvWin.name = 'txtLvWin';

	var _modalLose = this.add.group(_uiGroup);
	_modalLose.name = 'modalLose';
	_modalLose.position.setTo(69.0, 300.0);

	var _bgLose = this.add.sprite(0.0, 0.0, 'all-images', 'line', _modalLose);
	_bgLose.name = 'bgLose';
	_bgLose.scale.setTo(6.0, 20.0);
	_bgLose.alpha = 0.8;

	var _labelLose = this.add.text(99.0, 29.0, 'Mission Failed', {"font":"20px Arial","fill":"#800040","align":"center"}, _modalLose);
	_labelLose.name = 'labelLose';

	var _txtLvLose = this.add.text(124.0, 74.0, '99', {"font":"bold 64px Arial","fill":"#800040","align":"center"}, _modalLose);
	_txtLvLose.name = 'txtLvLose';

	var _squareIndicator = this.add.sprite(210.0, 385.0, 'all-images', 'dot');
	_squareIndicator.name = 'squareIndicator';
	_squareIndicator.scale.setTo(40.0, 40.0);
	_squareIndicator.alpha = 0.2;
	_squareIndicator.anchor.setTo(0.5, 0.5);

	_modalWin.setAll("visible", false);
	_modalLose.setAll("visible", false);


	// public fields

	this.fStage = _stage;
	this.fLinesGroup = _linesGroup;
	this.fDotsGroup = _dotsGroup;
	this.fParticlesGroup = _particlesGroup;
	this.fUiGroup = _uiGroup;
	this.fImgDotGoal = _imgDotGoal;
	this.fTxtGoal = _txtGoal;
	this.fTxtMove = _txtMove;
	this.fModalBg = _modalBg;
	this.fModalWin = _modalWin;
	this.fTxtLvWin = _txtLvWin;
	this.fModalLose = _modalLose;
	this.fTxtLvLose = _txtLvLose;
	this.fSquareIndicator = _squareIndicator;

	//--Generated code from canvas user code
	this.makeBitmapTextFrom( _btnBackText, 'NUnito', true );
	this.initStage();

};

/* --- end generated code --- */
// -- user code here --

// CONSTANTS
Battle.prototype.GRID_WIDTH             = 6;    // columns
Battle.prototype.GRID_HEIGHT            = 6;    // rows
Battle.prototype.DOT_SIZE               = 32;   // px;
Battle.prototype.DOT_SPACE              = 20;   // px
Battle.prototype.FALL_1_FLOOR_DURATION  = 150;  // ms
Battle.prototype.DOT_ANIM_DURATION      = 150;  // ms
Battle.prototype.HIGHLIGHT_DURATION     = 400;  // ms
Battle.prototype.SHUFFLE_DURATION       = 400;  // ms
Battle.prototype.LIVE_LINE_LENGTH       = 52;   // px
Battle.prototype.EXPLODE_MAX_PARTICLES  = 5;
Battle.prototype.EXPLODE_LIFE_SPAN      = 1600;
Battle.prototype.EMPTY                  = 0;
Battle.prototype.HOLE                   = -1;
Battle.prototype.COLORS                 = [0xFFE368, 0xDD3562, 0x59C9A5, 0x1A8FE3, 0x5E239D, 0x171219, 0xF7FFF6]; // Yellow, Red, Green, Blue, Purple, Black, White
Battle.prototype.PHASES                 = ["ACTION", "Wait..."];
Battle.prototype.PHASE_ACTION           = 0;
Battle.prototype.PHASE_WAIT             = 1;
Battle.prototype.MAX_SHUFFLE_TRY        = 5;
Battle.prototype.RESULT_IN_PROGRESS     = 0;
Battle.prototype.RESULT_WIN             = 1;
Battle.prototype.RESULT_LOSE            = 2;
//-----------------------------------------------------------------------------------------------------------
// CONFIG
Battle.prototype.DEBUG_ENABLE           = false;
Battle.prototype.PARTICLE_ENABLE        = true;
Battle.prototype.USE_EXPORTED_PARTICLE  = false; // TODO: didn't work yet
Battle.prototype.SPINE_ENABLE           = true;
Battle.prototype.LIVE_LINE_ENABLE       = true;
Battle.prototype.USE_TWEEN_POOL         = false; // doesn't work yet, because giving tween back to pool needs callback
Battle.prototype.FX_CONNECT_ENABLE      = true;
//-----------------------------------------------------------------------------------------------------------
// PROPERTIES
Battle.prototype.poolOfDots             = null;
Battle.prototype.mapOfLines             = [];
Battle.prototype.listOfVisibleLines     = [];
Battle.prototype.mapOfExplodeFxs        = [];
Battle.prototype.tableOfTypes           = [];
Battle.prototype.tableOfDots            = [];
Battle.prototype.phase                  = Battle.prototype.PHASE_WAIT;
Battle.prototype.listOfConnectedDots    = [];
Battle.prototype.connectingType         = Battle.prototype.EMPTY;
Battle.prototype.isSquareFormed         = false;
Battle.prototype.avatar                 = null;
Battle.prototype.isGrabbing             = false;
Battle.prototype.liveLine               = null;
Battle.prototype.mapOfSfxs              = [];
Battle.prototype.cachedStageX           = 0;
Battle.prototype.cachedStageY           = 0;
Battle.prototype.cachedGroupX           = 0;
Battle.prototype.cachedGroupY           = 0;
Battle.prototype.poolOfTweens           = null;
Battle.prototype.mapOfConnectFxs        = [];
Battle.prototype.currentLevelSettings   = null;
Battle.prototype.colorsInLevel          = null;
Battle.prototype.requiredColor          = 0;
Battle.prototype.countMoves             = 0;
Battle.prototype.countClear             = 0;
//-----------------------------------------------------------------------------------------------------------
/**
 * Initialize everything
 */
Battle.prototype.initStage = function () {
    // Cache unchanged numbers
    this.cachedStageX = this.fStage.x;
    this.cachedStageY = this.fStage.y;
    this.cachedGroupX = this.fDotsGroup.x;
    this.cachedGroupY = this.fDotsGroup.y;

    // Init map
    this.resetTableOfTypes();
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        this.tableOfDots[i] = [];
    }
    // assertEqual( this.tableOfTypes.length, this.GRID_WIDTH );
    // assertEqual( this.tableOfTypes[0].length, this.GRID_HEIGHT );

    // Init many things
    this.initPoolOfDots();
    this.initLineGrid();
    this.initParticles();
    this.initAnimations();
    this.initAudio();
    this.initTweens();
    this.initConnectFxs();
    this.initSquareIndicator();

    // Load level data
    if (!this.game.data.level) {
        this.game.data.level = new LevelManager( this.cache.getJSON( 'levels' ) );
        this.game.data.level.debug();
    }
    this.currentLevelSettings   = this.game.data.level.getLevel( this.game.data.userLevel );
    this.colorsInLevel          = this.currentLevelSettings.colors;
    this.requiredColor          = Phaser.ArrayUtils.getRandomItem( this.colorsInLevel );
    this.countMoves             = 0;
    this.countClear             = 0;
    console.log( 'LEVEL ' + this.game.data.userLevel, this.currentLevelSettings );
    console.log( '%c Required color = ' + this.requiredColor, 'background: #' + this.COLORS[ this.requiredColor - 1 ].toString(16) + '; color: #000' );
    this.initUI();

    // Move dots from poolOfDots to tableOfDots
    this.spawnDots();

    // Setup interaction
    this.input.onDown.add( this.onGrab, this );
    this.input.addMoveCallback( this.onMovePointer, this );
    this.input.onUp.add( this.onRelease, this );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Spawn new dots into tableOfDots
 * @param excludeType : don't pick this color (bonus when square is formed)
 */
Battle.prototype.spawnDots = function (excludeType) {
    var duration = 0;
    var longestDuration = 0;

    // Setup colors to pick
    var availableColors = this.colorsInLevel.slice();
    var excludedColorIndex = availableColors.indexOf( excludeType );
    if (excludedColorIndex > -1) {
        availableColors.splice( excludedColorIndex, 1 );
    }
//    console.log( "exclude " + excludeType + " => " + availableColors );


    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        // move old dots down
        var kOccupied;
        var kEmpty = this.GRID_HEIGHT - 1;
        do {
            while (kEmpty >= 0 && !this.isEmpty( this.tableOfTypes[i][kEmpty] )) { --kEmpty; }          // find empty slot (may not found)
            kOccupied = kEmpty - 1;
            while (kOccupied >= 0 && !this.isDot( this.tableOfTypes[i][kOccupied] )) { --kOccupied; }   // find occupied slot above empty slot (may not found)
            if (kOccupied >= 0 && kEmpty >= 0) { // fact: kOccupied != kEmpty
                // move dot to empty slot
                /** @type Phaser.Sprite */ var dot = this.tableOfDots[i][kOccupied];
                this.tableOfDots[i][kOccupied] = null;
                this.tableOfDots[i][kEmpty]    = dot;

                // update type matrix
                // assert( this.isEmpty( this.tableOfTypes[i][kEmpty] ), 'slot[' + i + '][' + kEmpty + '] = ' + this.tableOfTypes[i][kEmpty] + ' => not empty' );
                // assert( this.isDot( this.tableOfTypes[i][kOccupied] ), 'slot[' + i + '][' + kOccupied + '] = ' + this.tableOfTypes[i][kOccupied] + ' => not a dot' );
                this.tableOfTypes[i][kEmpty]    = this.tableOfTypes[i][kOccupied];
                this.tableOfTypes[i][kOccupied] = this.EMPTY;

                // tween
                duration = this.FALL_1_FLOOR_DURATION * (kEmpty - kOccupied);
                if (this.USE_TWEEN_POOL) {
                    this.getTweenFor( dot )
                        .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
                } else {
                    this.add.tween(dot)
                        .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
                }
                longestDuration = Math.max( duration, longestDuration );
            }
        } while (kOccupied >= 0 && kEmpty >= 0);

        // skip if column is full
        if (kEmpty < 0) { continue; }

        // spawn new dots
        var countNewDots = kEmpty + 1;
        var duration     = this.FALL_1_FLOOR_DURATION * countNewDots;
        while (kEmpty >= 0) {
            if (this.isEmpty( this.tableOfTypes[i][kEmpty] )) {
                // Don't need to have /** @type */ before 'var', because 'getDotFromPool' specified return type
                /** @type Phaser.Sprite */ var dot = this.getDotFromPool();
                dot.position.set( this.colToX( i ), this.rowToY( kEmpty - countNewDots ) );

                // save position & type
                var dotType                  = Phaser.ArrayUtils.getRandomItem( availableColors );
                this.tableOfDots[i][kEmpty]  = dot;
                this.tableOfTypes[i][kEmpty] = dotType;
                dot.tint                     = this.COLORS[ dotType - 1 ];

                // tween
                if (this.USE_TWEEN_POOL) {
                    this.getTweenFor( dot )
                        .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
                } else {
                    this.add.tween(dot)
                        .to( {y: this.rowToY( kEmpty )}, duration, Phaser.Easing.Bounce.Out, true);
                }
            }
            // else { console.log( 'Hole' ); }
            --kEmpty;
        }
        longestDuration = Math.max( duration, longestDuration );
    }

    this.time.events.add( longestDuration, this.postSpawn, this );

//    console.log("after spawning");
//    this.poolOfDots.debug();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Post-spawning: Check if player can match dots or not.
 * If he stucks, shuffle the dots to ensure he can match.
 */
Battle.prototype.postSpawn = function () {
    var result = this.checkWin();
    if (result == this.RESULT_WIN) {
        this.onWin();
        return;
    } else if (result == this.RESULT_LOSE) {
        this.onLose();
        return;
    }

    if (this.canMatch()) {
        this.switchPhase( this.PHASE_ACTION );
    } else {
        console.warn( 'Need shuffling' );
        this.shuffleForPossibleMove();
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Create all dots needed for the game and put them in a poolOfDots for re-using later
 */
Battle.prototype.initPoolOfDots = function () {
    var capacity    = this.GRID_WIDTH * this.GRID_HEIGHT * 2;
    this.poolOfDots = new RecyclePool( capacity );
    var dotsGroup   = this.fDotsGroup;
    for (var i = 0; i < capacity; ++i) {
        /** @type Phaser.Sprite */ var dot = this.add.sprite( 0, 0, 'all-images', 'dot', dotsGroup );
        dot.anchor.set( 0.5 );
        dot.data = { id : i }; // for debug only
        dot.name = 'dot_' + i; // to view in Phaser.Plugin.Debug.SceneTree
        this.returnDotToPool( dot );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * @returns {Phaser.Sprite} Dot (in poolOfDots) ready to use
 */
Battle.prototype.getDotFromPool = function () {
    /** @type Phaser.Sprite */ var dot = this.poolOfDots.takeOut();
    dot.scale.set( 1 );
    dot.visible    = true;
    return dot;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param dot : This dot is destroyed -> put back into poolOfDots
 */
Battle.prototype.returnDotToPool = function (dot) {
    dot.visible     = false;
    this.poolOfDots.giveBack( dot );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Initialize connections between dots
 */
Battle.prototype.initLineGrid = function () {
    var linesGroup = this.fLinesGroup;
    for (var i = 0; i < this.GRID_WIDTH - 1; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            /** @type Phaser.Sprite */ var line = this.add.sprite( 0, 0, 'all-images', 'line', linesGroup );
            line.anchor.set( 0, 0.5 );
            line.position.set( this.colToX(i), this.rowToY(k) );
            line.visible    = false;

            var id1 = this.colRowToIndex(i, k);
            var id2 = this.colRowToIndex(i + 1, k);
            this.mapOfLines[ this.getLineIndexBetween(id1, id2) ] =
            this.mapOfLines[ this.getLineIndexBetween(id2, id1) ] = line;
            line.name = 'line_' + this.getLineIndexBetween(id1, id2); // to view in Phaser.Plugin.Debug.SceneTree
        }
    }

    var rotation = Math.PI / 2;
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT - 1; ++k) {
            /** @type Phaser.Sprite */ var line = this.add.sprite( 0, 0, 'all-images', 'line', linesGroup );
            line.anchor.set( 0, 0.5 );
            line.position.set( this.colToX(i), this.rowToY(k) );
            line.rotation   = rotation;
            line.visible    = false;

            var id1 = this.colRowToIndex(i, k);
            var id2 = this.colRowToIndex(i, k + 1);
            this.mapOfLines[ this.getLineIndexBetween(id1, id2) ] =
            this.mapOfLines[ this.getLineIndexBetween(id2, id1) ] = line;
            line.name = 'line_' + this.getLineIndexBetween(id1, id2); // to view in Phaser.Plugin.Debug.SceneTree
        }
    }

    if (!this.LIVE_LINE_ENABLE) { return; }
    /** @type Phaser.Sprite */ var line = this.add.sprite( 0, 0, 'all-images', 'line', linesGroup );
    line.anchor.set( 0, 0.5 );
    line.visible    = false;
    this.liveLine   = line;
    line.name = 'line_LIVE'; // to view in Phaser.Plugin.Debug.SceneTree
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param i1 : Index of dot #1
 * @param i2 : Index of dot #2
 * @returns Key to get connection between these dots
 */
Battle.prototype.getLineIndexBetween = function (i1, i2) {
    return (i1 + '_' + i2);
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param i1 : Index of dot #1
 * @param i2 : Index of dot #2
 * @returns Connection between these dots
 */
Battle.prototype.getLineBetween = function (i1, i2) {
    return this.mapOfLines[ this.getLineIndexBetween( i1, i2 ) ];
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * Hide all dot connections
 */
Battle.prototype.hideGridLines = function () {
    for (var i = 0; i < this.listOfVisibleLines.length; ++i) {
        this.listOfVisibleLines[i].visible      = false;
    }
    this.listOfVisibleLines = [];

    if (!this.LIVE_LINE_ENABLE) { return; }
    this.liveLine.visible       = false;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param t : Dot type in this slot
 * @returns Check if this slot is empty or not
 */
Battle.prototype.isEmpty = function (t) {
    return (t == this.EMPTY);
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param t : Dot type in this slot
 * @returns Check if this slot is a hole or not
 */
Battle.prototype.isHole = function (t) {
    return (t == this.HOLE);
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param t : Dot type in this slot
 * @returns Check if this slot contains a dot or not
 */
Battle.prototype.isDot = function (t) {
    return !this.isEmpty( t ) && !this.isHole( t );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [INPUT] On mouse down
 */
Battle.prototype.onGrab = function () {
    /** @type Phaser.Pointer */ var pointer = this.input.activePointer;
    var col = Math.floor( (pointer.position.x - this.cachedStageX) / (this.DOT_SIZE + this.DOT_SPACE) );
    var row = Math.floor( (pointer.position.y - this.cachedStageY) / (this.DOT_SIZE + this.DOT_SPACE) );
    this.isGrabbing = this.isOnBoard( col, row );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [INPUT] On mouse move
 * @param pointer
 */
Battle.prototype.onMovePointer = function (pointer) {
    if (this.phase != this.PHASE_ACTION) { return; }    // not ACTION time
    if (!pointer.isDown) { return; }                    // no touching
    if (!this.isGrabbing) { return; }                   // first touch is outside of stage

    var col = Math.floor( (pointer.position.x - this.cachedStageX) / (this.DOT_SIZE + this.DOT_SPACE) );
    var row = Math.floor( (pointer.position.y - this.cachedStageY) / (this.DOT_SIZE + this.DOT_SPACE) );
    if (this.isOnBoard( col, row )) {
        this.onTouch( col, row );
    }

    if (!this.LIVE_LINE_ENABLE) { return; }
    if (this.listOfConnectedDots.length == 0) {
        return;
    }
    /** @type Phaser.Point */ var dotPos = this.liveLine.position;
    /** @type Phaser.Point */ var curPos = new Phaser.Point( pointer.position.x - this.cachedGroupX, pointer.position.y - this.cachedGroupY );
    this.liveLine.scale.set( (dotPos.distance( curPos )) / this.LIVE_LINE_LENGTH, 1 );
    this.liveLine.rotation = dotPos.angle( curPos );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [INPUT] On mouse up
 */
Battle.prototype.onRelease = function () {
    this.isGrabbing = false;
    if (!this.isConnecting()) { return; }

    if (this.listOfConnectedDots.length > 1) {
        this.matchDots();
        this.spawnDots( this.connectingType );
    } else {
        this.cancelConnecting();
    }

    this.connectingType = this.EMPTY;
    this.hideSquareIndicator();
    this.hideGridLines();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [DEBUG]
 */
Battle.prototype.render = function () {
    if (this.DEBUG_ENABLE) {
        // PHASE
        this.debug.text( this.PHASES[ this.phase ], 10, 20, 'red' );

        // DOTS - TYPE (if debug text has same color with dot (hard to read) => correct)
        var offsetX = this.cachedStageX + this.DOT_SIZE / 2 - 12;
        var offsetY = this.cachedStageY + this.DOT_SIZE / 2;
        for (var i = 0; i < this.GRID_WIDTH; ++i) {
            for (var k = 0; k < this.GRID_HEIGHT; ++k) {
                if (this.isDot( this.tableOfTypes[i][k] )) {
                    this.debug.text(
                        this.tableOfTypes[i][k],
                        offsetX + this.tableOfDots[i][k].x,
                        offsetY + this.tableOfDots[i][k].y,
                        Phaser.Color.getWebRGB( this.COLORS[ this.tableOfTypes[i][k] - 1 ] )
                    );
                }
            }
        }

        // DOTS - CONNECTING
        if (this.phase != this.PHASE_ACTION || !this.isConnecting()) { return; }
        for (var i = 0; i < this.listOfConnectedDots.length; ++i) {
            var c = this.indexToCol( this.listOfConnectedDots[i] );
            var r = this.indexToRow( this.listOfConnectedDots[i] );
            this.debug.spriteBounds( this.tableOfDots[c][r] );
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * Main game logic: Handle when mouse touches dot
 * @param col
 * @param row
 */
Battle.prototype.onTouch = function (col, row) {
    var type = this.tableOfTypes[col][row];
    if (!this.isDot( type )) { return; }

    // Case 1: Set as 1st dot---------------------------------------------
    var index = this.colRowToIndex( col, row );
    if (!this.isConnecting()) {
        this.connectingType      = type;
        this.listOfConnectedDots = [ index ];
        this.isSquareFormed      = false;
        this.onConnectNewDot( index );
        console.log( "Begin connecting " + type + ": " + this.listOfConnectedDots );
        return;
    }

    // early reject from case 2, 3, 4
    var dotsCount = this.listOfConnectedDots.length;
    if (type != this.connectingType) { return; }                                // is different color
    if (index == this.listOfConnectedDots[ dotsCount - 1 ]) { return; }                    // is last connected dot
    if (!this.isAdjacent(index, this.listOfConnectedDots[ dotsCount - 1 ])) { return; }    // is not adjacent

    // Case 2: Cancel newest dot---------------------------------------------
    var duplicatedPos = this.listOfConnectedDots.indexOf( index );
    var lastDotIndex  = this.listOfConnectedDots[ dotsCount - 1 ];
    if (duplicatedPos > -1 && duplicatedPos == dotsCount - 2) {
        this.onDisconnectDot( lastDotIndex, this.listOfConnectedDots[ dotsCount - 2 ] );
        this.listOfConnectedDots.pop();
        this.isSquareFormed = false;
        this.hideSquareIndicator();
        console.log( "\tReject " + type + ": " + this.listOfConnectedDots );
        return;
    }

    // If square was formed already -> early reject from case 3, 4
    if (this.isSquareFormed) { return; }

    // Case 3: Add new dot---------------------------------------------
    if (duplicatedPos == -1) {
        this.listOfConnectedDots.push( index );
        this.onConnectNewDot( index, lastDotIndex );
        console.log( "\tAdd " + type + ": " + this.listOfConnectedDots );
        return;
    }

    // If there's not enough dots to form a square -> early reject from case 4
    if (duplicatedPos > dotsCount - 4) { return; }

    // Case 4: Square---------------------------------------------
    var turnsCount = 0;
    var direction = this.isAdjacentAndOnSameRow( this.listOfConnectedDots[ duplicatedPos ], this.listOfConnectedDots[ duplicatedPos + 1 ] );
    do {
        ++duplicatedPos;
        var newDirection = this.isAdjacentAndOnSameRow( this.listOfConnectedDots[ duplicatedPos ], this.listOfConnectedDots[ duplicatedPos + 1 ] );
        if (direction != newDirection) {
            direction = newDirection;
            ++turnsCount;
        }
    } while (duplicatedPos < dotsCount - 1);
    if (turnsCount < 4) {
        this.listOfConnectedDots.push( index );
        this.onConnectNewDot( index, lastDotIndex );
        console.log( "\t[SQUARE] Re-Add " + type + ": " + this.listOfConnectedDots );
        this.isSquareFormed = true;
        this.showSquareIndicator( col, row, this.connectingType );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * On mouse up and there're dots to match
 */
Battle.prototype.matchDots = function () {
    if (!this.isConnecting()) { return; }

    this.switchPhase( this.PHASE_WAIT );
    if (this.isSquareFormed) {
        console.log( "Clear ALL dots type " + this.connectingType );
        this.clear( this.getDotsWhichIs( this.connectingType ) );
        this.camera.shake( 0.01, this.DOT_ANIM_DURATION ); // UI is fixed with camera
        this.sfx( 'clear' );
    } else {
        console.log( "Clear matched dots type " + this.connectingType );
        this.clear( this.listOfConnectedDots );
        this.sfx( 'match' );
    }
    this.animateAvatarOnMatch( this.isSquareFormed );

    ++this.countMoves;
    console.log( "Moves left = " + (this.currentLevelSettings.moves - this.countMoves) );
    this.invalidateUI();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * On mouse up and there're not enough dots to match
 */
Battle.prototype.cancelConnecting = function () {
    for (var i = 0; i < this.listOfConnectedDots.length; ++i) {
        this.onDisconnectDot( this.listOfConnectedDots[i] );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * @param indices : Index of dots to be destroyed
 */
Battle.prototype.clear = function (indices) {
    var dots = [];
    var color = this.connectingType;
    for (var i = 0; i < indices.length; ++i) {
        var id  = indices[i];
        var c   = this.indexToCol( id );
        var r   = this.indexToRow( id );

        // assert( this.isDot( this.tableOfTypes[c][r] ), 'slot[' + c + '][' + r + '] = ' + this.tableOfTypes[c][r] + ' => not a dot' );
        this.tableOfTypes[c][r] = this.EMPTY;
        dots.push( this.tableOfDots[c][r] );

        if (this.USE_TWEEN_POOL) {
            this.getTweenFor( this.tableOfDots[c][r].scale )
                .to( {x: 0, y:0}, this.DOT_ANIM_DURATION, Phaser.Easing.Quadratic.Out, true );
        } else {
            this.add.tween( this.tableOfDots[c][r].scale )
                .to( {x: 0, y:0}, this.DOT_ANIM_DURATION, Phaser.Easing.Quadratic.Out, true );
        }

        this.showParticleAt( id, color );
    }
    this.time.events.add( this.DOT_ANIM_DURATION, this.postClear, this, dots );

    if ( color == this.requiredColor ) {
        this.countClear += indices.length;
        console.log( "Collected: " + this.countClear + "/" + this.currentLevelSettings.target );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @param dots : Wait for dots to finish 'EXPLODE' animation, then return them to poolOfDots to re-use later
 */
Battle.prototype.postClear = function (dots) {
    for (var i = 0; i < dots.length; ++i) {
        this.returnDotToPool( dots[i] );
    }

//    console.log("post clearing");
//    this.poolOfDots.debug();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * @returns
 * @param type : Filter dots by color (type)
 */
Battle.prototype.getDotsWhichIs = function (type) {
    var dots = [];
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            if (this.tableOfTypes[i][k] == type) {
                dots.push( this.colRowToIndex(i, k) );
            }
        }
    }
    return dots;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] VFX when connect new dot
 * @param newDotIndex : New connected dot
 * @param lastDotIndex : Last dot before connecting
 */
Battle.prototype.onConnectNewDot = function (newDotIndex, lastDotIndex) {
    var c = this.indexToCol( newDotIndex );
    var r = this.indexToRow( newDotIndex );
    /** @type Phaser.Sprite */ var dot = this.tableOfDots[c][r];

    // highlight dot
    if (this.FX_CONNECT_ENABLE) {
        this.showConnectFxAt( c, r );
    } else {
        if (this.USE_TWEEN_POOL) {
            this.stopTweensOf( dot.scale );
            this.getTweenFor( dot.scale )
                .to( { x : 1.2, y : 1.2 }, this.DOT_ANIM_DURATION, Phaser.Easing.Bounce.Out, true );
        } else {
            this.tweens.remove( dot.scale );
            this.add.tween( dot.scale )
                .to( { x : 1.2, y : 1.2 }, this.DOT_ANIM_DURATION, Phaser.Easing.Bounce.Out, true );
        }
    }
    this.sfx( 'connect' );

    // show connection
    if (lastDotIndex != undefined) {
        /** @type Phaser.Sprite */ var line = this.getLineBetween( newDotIndex, lastDotIndex );
        if (this.listOfVisibleLines.indexOf(line) > -1) {
            return;
        }
        this.listOfVisibleLines.push( line );
        line.tint       = this.COLORS[ this.connectingType - 1 ];
        line.visible    = true;
    }

    if (!this.LIVE_LINE_ENABLE) { return; }
    this.liveLine.position      = dot.position;
    this.liveLine.tint          = this.COLORS[ this.connectingType - 1 ];
    this.liveLine.visible       = true;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] VFX when disconnect a dot
 * @param dotIndex : Disconnected dot
 * @param lastDotIndex : New last dot
 */
Battle.prototype.onDisconnectDot = function (dotIndex, lastDotIndex) {
    var c = this.indexToCol( dotIndex );
    var r = this.indexToRow( dotIndex );
    /** @type Phaser.Sprite */ var dot = this.tableOfDots[c][r];

    // un-highlight dot
    if (!this.FX_CONNECT_ENABLE) {
        if (this.USE_TWEEN_POOL) {
            this.stopTweensOf( dot.scale );
            this.getTweenFor( dot.scale )
                .to( { x : 1, y : 1 }, this.DOT_ANIM_DURATION, Phaser.Easing.Cubic.Out, true );
        } else {
            this.tweens.remove( dot.scale );
            this.add.tween( dot.scale )
                .to( { x : 1, y : 1 }, this.DOT_ANIM_DURATION, Phaser.Easing.Cubic.Out, true );
        }
    }
    this.sfx( 'disconnect' );

    // hide connection
    if (lastDotIndex != undefined) {
        /** @type Phaser.Sprite */ var line = this.getLineBetween( dotIndex, lastDotIndex );
        var lineIndex = this.listOfVisibleLines.lastIndexOf( line );
        if (lineIndex == -1) {
            return;
        }
        this.listOfVisibleLines.splice( lineIndex, 1 );
        line.visible    = false;

        if (!this.LIVE_LINE_ENABLE) { return; }
        var c = this.indexToCol( lastDotIndex );
        var r = this.indexToRow( lastDotIndex );
        /** @type Phaser.Sprite */ var dot = this.tableOfDots[c][r];
        this.liveLine.position = dot.position;
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 *
 */
Battle.prototype.initSquareIndicator = function () {
    this.hideSquareIndicator();
    this.fSquareIndicator.scale.set( 0 );
    /** @type Phaser.Tween */var tween = this.add.tween( this.fSquareIndicator.scale )
        .to( { x : 40, y : 40 }, 200 ).loop().start();
    tween.pause();
    tween.onLoop.add( this._onSquareIndicatorLoop, this );
    this.fSquareIndicator.data = { tween : tween };

    // TODO: Can't restart tween now -> Trick: Repeat tween infinitely, but pause after each loop, then resume later
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] VFX when a square is formed
 * @param col
 * @param row
 * @param type : Square color
 */
Battle.prototype.showSquareIndicator = function (col, row, type) {
    /** @type Phaser.Point */var p = this.tableOfDots[col][row].worldPosition;
    this.fSquareIndicator.position.setTo( p.x, p.y );
    this.fSquareIndicator.tint          = this.COLORS[ type - 1 ];
    this.fSquareIndicator.visible       = true;
    if (this.fSquareIndicator.data.tween.isPaused) {
        this.fSquareIndicator.data.tween.resume();
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC] Hide square VFX
 */
Battle.prototype.hideSquareIndicator = function () {
    this.fSquareIndicator.visible       = false;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [GRAPHIC]
 * @param target : tween target (passed by Phaser.Tween.onLoop)
 * @param tween : tween (passed by Phaser.Tween.onLoop)
 */
Battle.prototype._onSquareIndicatorLoop = function (target, tween) {
    tween.pause();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [PARTICLES] Create particles (without starting)
 */
Battle.prototype.initParticles = function () {
    if (!this.PARTICLE_ENABLE) { return; }
    var particlesGroup = this.fParticlesGroup;

    if (this.USE_EXPORTED_PARTICLE) {
        var fxExplode = this.cache.getJSON( 'fx-explode' );
        for (var i = 0; i < this.GRID_WIDTH; ++i) {
            for (var k = 0; k < this.GRID_HEIGHT; ++k) {
                /** @type Phaser.Group */
                var emitter = this.game.epsy.loadSystem( fxExplode, 200, 200 );
                particlesGroup.add( emitter );
                emitter.position.set( this.colToX(i), this.rowToY(k) );
                this.mapOfExplodeFxs[ this.colRowToIndex(i, k) ] = emitter;
            }
        }
    } else {
        for (var i = 0; i < this.GRID_WIDTH; ++i) {
            for (var k = 0; k < this.GRID_HEIGHT; ++k) {
                /** @type Phaser.Emitter */ var emitter = this.add.emitter( 0, 0, this.EXPLODE_MAX_PARTICLES );
                particlesGroup.add( emitter );
                emitter.makeParticles( 'all-images', 'dot' );
                emitter.position.set( this.colToX(i), this.rowToY(k) );
                emitter.gravity = 0;
                emitter.setAlpha( 1, 0, this.EXPLODE_LIFE_SPAN );
                emitter.setScale( 0.5, 0, 0.5, 0, this.EXPLODE_LIFE_SPAN );
                emitter.setXSpeed( -200, 200 );
                emitter.setYSpeed( -200, 200 );
                this.mapOfExplodeFxs[ this.colRowToIndex(i, k) ] = emitter;

                emitter.name = 'fx_explode_' + this.colRowToIndex(i, k); // to view in Phaser.Plugin.Debug.SceneTree
            }
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [PARTICLES] VFX when a dot explodes
 * @param index : Dot index
 * @param type : Dot color
 */
Battle.prototype.showParticleAt = function (index, type) {
    if (!this.PARTICLE_ENABLE) { return; }

    if (this.USE_EXPORTED_PARTICLE) {
//        this.mapOfExplodeFxs[ index ].emit();
    } else {
        /** @type Phaser.Emitter */ var emitter = this.mapOfExplodeFxs[ index ];
        var color = this.COLORS[ type - 1 ];
        emitter.forEach( function (particle) {
            particle.tint = color;
        } );
        emitter.explode( this.EXPLODE_LIFE_SPAN, this.EXPLODE_MAX_PARTICLES );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [SPINE ANIMATION] Create an instance
 */
Battle.prototype.initAnimations = function () {
    if (!this.SPINE_ENABLE) { return; }

    this.avatar = this.add.spine( 100, this.game.height, 'avatar' );
    this.avatar.scale.set( 0.3 );
    this.avatar.setAnimationByName( 0, 'idle', true );
    this.avatar.name = 'avatar'; // to view in Phaser.Plugin.Debug.SceneTree

    // Move spine under UI
    this.world.setChildIndex( this.avatar, this.world.getChildIndex( this.fUiGroup ) );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [SPINE ANIMATION] Animate avatar when clearing dots
 * @param clearAll : All dots of certain color are cleared
 */
Battle.prototype.animateAvatarOnMatch = function (clearAll) {
    if (!this.SPINE_ENABLE) { return; }

    if (clearAll) {
        this.avatar.setAnimationByName( 0, 'jump', false );
        this.avatar.setAnimationByName( 1, 'shoot', false );
    } else {
        this.avatar.setAnimationByName( 0, 'shoot', false );
    }
    this.avatar.addAnimationByName( 0, 'idle', true );  // play 'idle' when finish
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [AUDIO] Spawn audio instances
 */
Battle.prototype.initAudio = function () {
    this.loadSfx( 'clear', 0.4 );
    this.loadSfx( 'connect', 0.5 );
    this.loadSfx( 'disconnect' );
    this.loadSfx( 'match' );
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [AUDIO] Load & cache SFX
 * @param key : SFX key
 * @param volume (optional) : SFX volume
 */
Battle.prototype.loadSfx = function (key, volume) {
    if (isNaN(volume)) {
        this.mapOfSfxs[ key ] = this.add.sound( 'sfx-' + key );
    } else {
        this.mapOfSfxs[ key ] = this.add.sound( 'sfx-' + key, volume );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [AUDIO] Play SFX
 * @param key : SFX key
 */
Battle.prototype.sfx = function (key) {
    /** @type Phaser.Sound */var s = this.mapOfSfxs[ key ];
    if (s != undefined) {
        s.play();
    } else {
        console.error( 'sfx "' + key + '" not found' );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [TWEEN] Init pool of tweens to recycle later
 */
Battle.prototype.initTweens = function () {
    if (!this.USE_TWEEN_POOL) { return; }

    var capacity      = this.GRID_WIDTH * this.GRID_HEIGHT * 2;
    this.poolOfTweens = new RecyclePool( capacity );
    for (var i = 0; i < capacity; ++i) {
        this.poolOfTweens.giveBack( this.add.tween() );
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [TWEEN] Get a tween from recycle pool, reset it
 * @param obj New tween target
 * @returns Tween ready to re-use
 */
Battle.prototype.getTweenFor = function (obj) {
    /** @type Phaser.Tween */var t = this.poolOfTweens.takeOut();
    t.target   = obj;
    t.timeline = [];
    return t;
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [TWEEN] Stop all tweens having target = obj
 * @param obj
 * @param complete
 */
Battle.prototype.stopTweensOf = function (obj, complete) {
    var allTweens = this.tweens.getAll();
    for (var i = allTweens.length - 1; i >= 0; --i) {
        if (allTweens[i].target == obj) {
            allTweens[i].stop( complete );
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [CONNECT FX] Create fx, set fixed position and hide all of them
 */
Battle.prototype.initConnectFxs = function () {
    if (!this.FX_CONNECT_ENABLE) { return; }

    var particlesGroup = this.fParticlesGroup;
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            var id = this.colRowToIndex(i, k);
            // Create sprite
            /** @type Phaser.Sprite */var fx = this.add.sprite( 0, 0, 'all-images', 'dot', particlesGroup );
            fx.position.set( this.colToX(i), this.rowToY(k) );
            fx.anchor.set( 0.5 );
            fx.visible = false;
            fx.name = 'fx_connect_' + id;

            // Create tweens (NOT auto-start)
            /** @type Phaser.Tween */var tweenScale = this.add.tween( fx.scale )
                .to( { x : 3, y : 3 }, this.HIGHLIGHT_DURATION, Phaser.Easing.Cubic.Out, true ).loop();
            tweenScale.pause();
            tweenScale.onLoop.add( this._hideConnectFx, this );

            /** @type Phaser.Tween */var tweenAlpha = this.add.tween( fx )
                .to( { alpha : 0 }, this.HIGHLIGHT_DURATION, Phaser.Easing.Cubic.Out, true ).loop();
            tweenAlpha.pause();
            tweenAlpha.onLoop.add( this._hideConnectFx, this );
            // don't use 'addOnce', because I want this callback to be executed everytime tween finishes

            this.mapOfConnectFxs[ id ] = {
                sprite : fx,
                tweens : [ tweenScale, tweenAlpha ]
            };
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [CONNECT FX] Show effect when connecting a new dot at a specific position
 * @param c : column
 * @param r : row
 */
Battle.prototype.showConnectFxAt = function (c, r) {
    var fx = this.mapOfConnectFxs[ this.colRowToIndex(c, r) ];
    fx.sprite.tint     = this.COLORS[ this.connectingType - 1 ];
    fx.sprite.visible  = true;

    fx.tweens[0].resume();
    fx.tweens[1].resume();
};
//-----------------------------------------------------------------------------------------------------------
/**
 * [CONNECT FX] Hide effect when it finished its tween (alpha = 0)
 * @param target : tween target (passed by Phaser.Tween.onLoop)
 * @param tween : tween (passed by Phaser.Tween.onLoop)
 */
Battle.prototype._hideConnectFx = function (target, tween) {
    target.visible = false;
    tween.pause();
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isOnBoard = function (c, r) {
    return (c >= 0 && r >= 0 && c < this.GRID_WIDTH && r < this.GRID_HEIGHT);
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.colRowToIndex = function (col, row) {
    return col * this.GRID_HEIGHT + row;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.indexToCol = function (index) {
    return Math.floor( index / this.GRID_HEIGHT );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.indexToRow = function (index) {
    return Math.floor( index % this.GRID_HEIGHT );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isAdjacentAndOnSameCol = function (i1, i2) { // i1, i2 must be on same column already
    return (Math.abs( i1 - i2 ) == 1);
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isAdjacentAndOnSameRow = function (i1, i2) { // i1, i2 must be on same row already
    return (Math.abs( i1 - i2 ) == this.GRID_WIDTH);
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isAdjacent = function (i1, i2) {
    var c1 = this.indexToCol( i1 );
    var c2 = this.indexToCol( i2 );
    if (c1 == c2) { // same column
        return this.isAdjacentAndOnSameCol( i1, i2 );
    }

    var r1 = this.indexToRow( i1 );
    var r2 = this.indexToRow( i2 );
    if (r1 == r2) { // same row
        return this.isAdjacentAndOnSameRow( i1, i2 );
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.colToX = function (c) {
    return c * (this.DOT_SIZE + this.DOT_SPACE) + 16;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.rowToY = function (r) {
    return r * (this.DOT_SIZE + this.DOT_SPACE) + 16;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.isConnecting = function () {
  return !this.isEmpty( this.connectingType );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.switchPhase = function (p) {
    this.phase = p;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.toMenuState = function () {
//    this.state.start( 'Menu', FadeOut, FadeIn ); // TODO: Not smooth enough, think of camera fading
    this.state.start( 'Menu' );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.canMatch = function () {
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            var c = this.tableOfTypes[i][k];
            if (!this.isDot( c )) {
                continue;
            }

            if (this.isOnBoard(i, k - 1) && c == this.tableOfTypes[i][k - 1]) {
                return true;
            }
            if (this.isOnBoard(i, k + 1) && c == this.tableOfTypes[i][k + 1]) {
                return true;
            }
            if (this.isOnBoard(i - 1, k) && c == this.tableOfTypes[i - 1][k]) {
                return true;
            }
            if (this.isOnBoard(i + 1, k) && c == this.tableOfTypes[i + 1][k]) {
                return true;
            }
        }
    }
    return false;
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.shuffleForPossibleMove = function () {
    // Convert a table to a list to shuffle
    var canMatch    = false;
    var slots       = [];
    var slotIndices = [];
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            if (this.isDot( this.tableOfTypes[i][k] )) {
                slots.push( this.tableOfTypes[i][k] );
                slotIndices.push( this.colRowToIndex( i, k ) );
                // dot @ slotIndices[x] = slots[x]
                // slotIndices  will stay unchanged
                // slots        will be shuffled
            }
        }
    }

    // Shuffle for several times
    for (var i = 0; (i < this.MAX_SHUFFLE_TRY) && !canMatch; ++i) {
        this._shuffle( slotIndices, slots );
        canMatch = this.canMatch();
        console.warn( '\tSHUFFLE: Try #' + (i + 1) + ' => can match? ' + canMatch );
    }

    // Invalidate after shuffling successfully, or create a new board
    if (canMatch) {
        // this.invalidateBoard();
        // this.switchPhase( this.PHASE_ACTION );
        this.invalidateBoardAfterShuffling();
    } else {
        this.resetTableOfTypes();
        this.spawnDots();
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype._shuffle = function (slotIndices, slots) {
    slots = shuffle( slots );
    for (var i = slots.length - 1; i >= 0; i--) {
        var c = this.indexToCol( slotIndices[i] );
        var r = this.indexToRow( slotIndices[i] );
        this.tableOfTypes[c][r] = slots[i];
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.invalidateBoard = function () {
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            if (this.isDot( this.tableOfTypes[i][k] )) {
                this.tableOfDots[i][k].tint = this.COLORS[ this.tableOfTypes[i][k] - 1 ];
            }
        }
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.invalidateBoardAfterShuffling = function () {
    var duration = this.SHUFFLE_DURATION;
    var x = this.game.world.centerX - this.fDotsGroup.x;
    var y = this.game.world.centerY - this.fDotsGroup.y;

    // Move dots to center then back to old position
    for (var i = 0; i < this.GRID_WIDTH; ++i) {
        for (var k = 0; k < this.GRID_HEIGHT; ++k) {
            if (!this.isDot( this.tableOfTypes[i][k] )) {
                continue;
            }
            var d = Math.floor(Math.random() * (duration - 200) + 200);
            this.tweens.remove( this.tableOfDots[i][k] );
            this.add.tween( this.tableOfDots[i][k] )
                .to( {x : x}, d, Phaser.Easing.Sinusoidal.Out, true)
                .yoyo( true, duration - d );
            this.add.tween( this.tableOfDots[i][k] )
                .to( {y : y}, d, Phaser.Easing.Linear.None, true) // different easing for x, y make curve
                .yoyo( true, duration - d );
        }
    }

    // When dots are in center, swap their colors
    this.time.events.add( duration, this.invalidateBoard, this );

    // When dots are back to their positions, enable user interaction
    this.time.events.add( duration * 2, this.switchPhase, this, this.PHASE_ACTION );
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.resetTableOfTypes = function () {
    this.tableOfTypes = [
        [   0,  0,  0,  0,  0,  0   ],
        [   0, -1,  0,  0,  0,  0   ],
        [   0,  0,  0,  0,  0,  0   ],
        [   0,  0,  0,  0,  0,  0   ],
        [   0,  0,  0,  0, -1, -1   ],
        [   0,  0,  0,  0, -1,  0   ]
    ];
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.initUI = function () {
    this.updateRequiredColorUI();
    this.invalidateUI();
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.invalidateUI = function () {
    this.fTxtMove.text = Math.max(0, this.currentLevelSettings.moves - this.countMoves).toString();
    this.fTxtGoal.text = Math.max(0, this.currentLevelSettings.target - this.countClear).toString();
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.updateRequiredColorUI = function () {
    this.fImgDotGoal.tint = this.COLORS[ this.requiredColor - 1 ];
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.checkWin = function () {
    if (this.countClear >= this.currentLevelSettings.target) {
        return this.RESULT_WIN;
    } else if (this.countMoves < this.currentLevelSettings.moves) {
        return this.RESULT_IN_PROGRESS;
    } else {
        return this.RESULT_LOSE;
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.onWin = function (isDebug) {
    console.log( "WIN" );
    var duration = 500;
    var delay    = 2000;

    // Modal
    this.fModalBg.renderable = true;
    this.add.tween( this.fModalBg )
        .from( { alpha : 0 }, duration, Phaser.Easing.Quadratic.Out, true );

    // Panel WIN content
    this.fTxtLvWin.text = this.game.data.userLevel.toString();

    // Panel WIN
    this.fModalWin.setAll( 'visible', true );
    this.add.tween( this.fModalWin )
        .from( { y : -300 }, duration, Phaser.Easing.Bounce.Out, true );

    // Delay next level action
    if (isDebug != true) {
        this.time.events.add( delay, this.postWin, this );
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.postWin = function () {
    if (this.game.data.userLevel < this.game.data.level.getMaxLevel()) {
        ++this.game.data.userLevel;
        this.state.restart();
    } else {
        console.warn( "You've just finished the game !!!" );
        this.toMenuState();
    }
};
//-----------------------------------------------------------------------------------------------------------
Battle.prototype.onLose = function (isDebug) {
    console.log( "LOSE" );
    var duration = 500;
    var delay    = 2000;

    // Modal
    this.fModalBg.renderable = true;
    this.add.tween( this.fModalBg )
        .from( { alpha : 0 }, duration, Phaser.Easing.Quadratic.Out, true );

    // Panel LOSE content
    this.fTxtLvLose.text = this.game.data.userLevel.toString();

    // Panel LOSE
    this.fModalLose.setAll( 'visible', true );
    this.add.tween( this.fModalLose )
        .from( { y : -300 }, duration, Phaser.Easing.Bounce.Out, true );

    // Delay next level action
    if (isDebug != true) {
        this.time.events.add( delay, this.toMenuState, this );
    }
};
